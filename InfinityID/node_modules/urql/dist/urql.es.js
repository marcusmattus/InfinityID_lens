import { createClient as e, createRequest as t } from "@urql/core";

export * from "@urql/core";

import { createContext as n, useContext as r, useRef as o, useState as s, useCallback as c, useEffect as u, useMemo as i } from "react";

import { toPromise as a, subscribe as l, onPush as f, takeWhile as d, onEnd as p } from "wonka";

const y = e({
  url: "/graphql"
});

const h = n(y);

const x = h.Provider;

const g = h.Consumer;

h.displayName = "UrqlContext";

let b = !1;

const useClient = () => {
  const e = r(h);
  if ("production" !== process.env.NODE_ENV && e === y && !b) {
    b = !0;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }
  return e;
};

const q = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};

const computeNextState = (e, t) => {
  const n = {
    ...e,
    ...t,
    data: void 0 !== t.data || t.error ? t.data : e.data,
    fetching: !!t.fetching,
    stale: !!t.stale
  };
  return ((e, t) => {
    if ("object" != typeof e || "object" != typeof t) {
      return e !== t;
    }
    for (const n in e) {
      if (!(n in t)) {
        return !0;
      }
    }
    for (const n in t) {
      if (e[n] !== t[n]) {
        return !0;
      }
    }
    return !1;
  })(e, n) ? n : e;
};

const hasDepsChanged = (e, t) => {
  for (let n = 0, r = t.length; n < r; n++) {
    if (e[n] !== t[n]) {
      return !0;
    }
  }
  return !1;
};

function useMutation(e) {
  const n = o(!0);
  const r = useClient();
  const [i, l] = s(q);
  const f = c(((o, s) => {
    l({
      ...q,
      fetching: !0
    });
    return a(r.executeMutation(t(e, o), s || {})).then((e => {
      if (n.current) {
        l({
          fetching: !1,
          stale: !!e.stale,
          data: e.data,
          error: e.error,
          extensions: e.extensions,
          operation: e.operation
        });
      }
      return e;
    }));
  }), [ r, e, l ]);
  u((() => {
    n.current = !0;
    return () => {
      n.current = !1;
    };
  }), []);
  return [ i, f ];
}

function useRequest(e, n) {
  const r = o(void 0);
  return i((() => {
    const o = t(e, n);
    if (void 0 !== r.current && r.current.key === o.key) {
      return r.current;
    } else {
      r.current = o;
      return o;
    }
  }), [ e, n ]);
}

function useQuery(e) {
  const t = useClient();
  const n = (e => {
    if (!e._react) {
      const t = new Set;
      const n = new Map;
      if (e.operations$) {
        l((e => {
          if ("teardown" === e.kind && t.has(e.key)) {
            t.delete(e.key);
            n.delete(e.key);
          }
        }))(e.operations$);
      }
      e._react = {
        get: e => n.get(e),
        set(e, r) {
          t.delete(e);
          n.set(e, r);
        },
        dispose(e) {
          t.add(e);
        }
      };
    }
    return e._react;
  })(t);
  const r = ((e, t) => e.suspense && (!t || !1 !== t.suspense))(t, e.context);
  const o = useRequest(e.query, e.variables);
  const a = i((() => {
    if (e.pause) {
      return null;
    }
    const s = t.executeQuery(o, {
      requestPolicy: e.requestPolicy,
      ...e.context
    });
    return r ? f((e => {
      n.set(o.key, e);
    }))(s) : s;
  }), [ n, t, o, r, e.pause, e.requestPolicy, e.context ]);
  const y = c(((e, t) => {
    if (!e) {
      return {
        fetching: !1
      };
    }
    let r = n.get(o.key);
    if (!r) {
      let s;
      const c = l((e => {
        r = e;
        if (s) {
          s(r);
        }
      }))(d((() => t && !s || !r))(e));
      if (null == r && t) {
        const e = new Promise((e => {
          s = e;
        }));
        n.set(o.key, e);
        throw e;
      } else {
        c.unsubscribe();
      }
    } else if (t && null != r && "then" in r) {
      throw r;
    }
    return r || {
      fetching: !0
    };
  }), [ n, o ]);
  const h = [ t, o, e.requestPolicy, e.context, e.pause ];
  const [x, g] = s((() => [ a, computeNextState(q, y(a, r)), h ]));
  let b = x[1];
  if (a !== x[0] && hasDepsChanged(x[2], h)) {
    g([ a, b = computeNextState(x[1], y(a, r)), h ]);
  }
  u((() => {
    const e = x[0];
    const t = x[2][1];
    let r = !1;
    const updateResult = e => {
      r = !0;
      g((t => {
        const n = computeNextState(t[1], e);
        return t[1] !== n ? [ t[0], n, t[2] ] : t;
      }));
    };
    if (e) {
      const o = l(updateResult)(p((() => {
        updateResult({
          fetching: !1
        });
      }))(e));
      if (!r) {
        updateResult({
          fetching: !0
        });
      }
      return () => {
        n.dispose(t.key);
        o.unsubscribe();
      };
    } else {
      updateResult({
        fetching: !1
      });
    }
  }), [ n, x[0], x[2][1] ]);
  const k = c((s => {
    const c = {
      requestPolicy: e.requestPolicy,
      ...e.context,
      ...s
    };
    g((e => [ r ? f((e => {
      n.set(o.key, e);
    }))(t.executeQuery(o, c)) : t.executeQuery(o, c), e[1], h ]));
  }), [ t, n, o, r, y, e.requestPolicy, e.context ]);
  return [ b, k ];
}

function useSubscription(e, t) {
  const n = useClient();
  const r = useRequest(e.query, e.variables);
  const a = o(t);
  a.current = t;
  const f = i((() => !e.pause ? n.executeSubscription(r, e.context) : null), [ n, r, e.pause, e.context ]);
  const d = [ n, r, e.context, e.pause ];
  const [y, h] = s((() => [ f, {
    ...q,
    fetching: !!f
  }, d ]));
  let x = y[1];
  if (f !== y[0] && hasDepsChanged(y[2], d)) {
    h([ f, x = computeNextState(y[1], {
      fetching: !!f
    }), d ]);
  }
  u((() => {
    const updateResult = e => {
      h((t => {
        const n = computeNextState(t[1], e);
        if (t[1] === n) {
          return t;
        }
        if (a.current && t[1].data !== n.data) {
          n.data = a.current(t[1].data, n.data);
        }
        return [ t[0], n, t[2] ];
      }));
    };
    if (y[0]) {
      return l(updateResult)(p((() => {
        updateResult({
          fetching: !1
        });
      }))(y[0])).unsubscribe;
    } else {
      updateResult({
        fetching: !1
      });
    }
  }), [ y[0] ]);
  const g = c((t => {
    const o = n.executeSubscription(r, {
      ...e.context,
      ...t
    });
    h((e => [ o, e[1], d ]));
  }), [ n, e.context, r ]);
  return [ x, g ];
}

function Mutation(e) {
  const t = useMutation(e.query);
  return e.children({
    ...t[0],
    executeMutation: t[1]
  });
}

function Query(e) {
  const t = useQuery(e);
  return e.children({
    ...t[0],
    executeQuery: t[1]
  });
}

function Subscription(e) {
  const t = useSubscription(e, e.handler);
  return e.children({
    ...t[0],
    executeSubscription: t[1]
  });
}

export { g as Consumer, h as Context, Mutation, x as Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };
//# sourceMappingURL=urql.es.js.map
